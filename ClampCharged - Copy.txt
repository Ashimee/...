(function () {
  /**
   * Clamp Extension API - BETA 1.7
   * @author Ashimee {https://github.com/Ashimee}
   */
  const soup_ =
    '!#%()*+,-./:;=?@[]^_`{|}~' +
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  window.Blockly = Clamp.Blockly;
  var hasOwn = (obj, key) => Object.prototype.hasOwnProperty(obj, key);
  Clamp.NVER = 1.7;
  if (!Clamp?.ExtAPI || Clamp.ExtAPI.VERSION > Clamp.NVER)
    Clamp.ExtAPI = {
      VERSION: Clamp.NVER,
      refreshToolbox(toolboxXML) {
        const workspace = Clamp.getWorkspace();
        Clamp.Toolbox = toolboxXML ?? Clamp.Toolbox;
        workspace.updateToolbox(Clamp.Toolbox);
        workspace.refreshToolboxSelection();
      },
      _pushCategory(xml) {
        let toolboxXML = Clamp.Toolbox;
        toolboxXML = toolboxXML.replace('</xml>', `\n${xml}\n</xml>`);
        Clamp.ExtAPI.refreshToolbox(toolboxXML);
        Clamp.getWorkspace().refreshTheme();
      },
      _copyBlkAttr(obj, old, new_) {
        obj[new_] = obj[old];
        delete obj[old];
        return obj;
      },
      _repCategory(name, newXML) {
        const doc = new DOMParser()
          .parseFromString(Clamp.Toolbox, 'text/html')
          .querySelector('xml');
        doc.querySelector(
          `category[name="${name.replaceAll('\\', '\\\\').replaceAll('"', '"')}"]`,
        ).outerHTML = newXML;
        return doc.outerHTML;
      },
      xmlEscape(unsafe) {
        return String(unsafe).replace(/[<>&'"]/g, (c) => {
          switch (c) {
            case '<':
              return '&lt;';
            case '>':
              return '&gt;';
            case '&':
              return '&amp;';
            case "'":
              return '&apos;';
            case '"':
              return '&quot;';
          }
        });
      },

      /**
       * Generate a unique ID, from Blockly.  This should be globally unique.
       * 87 characters ^ 20 length > 128 bits (better than a UUID).
       * @return {string} A globally unique ID string.
       */
      uid() {
        const length = 20;
        const soupLength = soup_.length;
        const id = [];
        for (let i = 0; i < length; i++) {
          id[i] = soup_.charAt(Math.random() * soupLength);
        }
        return id.join('');
      },
      _svl: {
        genHeader(ei) {
          const xe = Clamp.ExtAPI.xmlEscape;
          let header =
            '<category name="%name" id="%id" colour="%c1" colourSecondary="%c2" colourTertiary="%c3">';
          header = header.replace('%name', xe(ei.name));
          header = header.replace('%id', xe(ei.name));
          header = header.replace('%c1', xe(ei.color1));
          header = header.replace('%c2', xe(ei.color2 ?? ei.color1));
          header = header.replace('%c3', xe(ei.color3 ?? ei.color1));
          return header;
        },
        fixMsnBsArgs(block, ei) {
          block.fullOp = `clampExt_${ei.id}_${block.opcode}`;
          block.fullOpXML = Clamp.ExtAPI.xmlEscape(block.fullOp);
          block.gen = ei.generators[block.opcode];
          if (!hasOwn(block, 'colour')) block.colour = ei.color1;
          if (!hasOwn(block, 'inputsInline')) block.inputsInline = true;
          if (!hasOwn(block, 'args0')) block.args0 = [];
          return block;
        },
        blkXML(fmbaBlock) {
          return `    <block type="${Clamp.ExtAPI.xmlEscape(fmbaBlock.fullOp)}"></block>`;
        },
      },
      register(extensionInfo) {
        const API = Clamp.ExtAPI,
          _svl = API._svl;
        Clamp.DarkTheme.blockStyles = Clamp.DarkTheme.blockStyles ?? {};
        Clamp.DarkTheme.blockStyles[`clampExt_${extensionInfo.id}`] = {
          colourPrimary: extensionInfo.color1,
          colourSecondary: extensionInfo.color2 ?? extensionInfo.color1,
          colourTertiary: extensionInfo.color3 ?? extensionInfo.color1,
        };
        const categoryXML = [_svl.genHeader(extensionInfo)];
        for (let block of extensionInfo.blocks) {
          if (block.isXML) {
            if (typeof block.isXML === 'string') categoryXML.push(block.isXML);
            else categoryXML.push(String(block?.xml));
            continue;
          }
          block = _svl.fixMsnBsArgs(block, extensionInfo);
          block = API._copyBlkAttr(block, 'arguments', 'args0');
          block = API._copyBlkAttr(block, 'text', 'message0');
          Clamp.registerBlock(block.fullOp, block, block.gen);
          if (!block?.skipXMLpush) categoryXML.push(_svl.blkXML(block));
        }
        categoryXML.push('</category>');
        const finalXML = categoryXML.join('');
        if (!extensionInfo?.skipPush) Clamp.ExtAPI._pushCategory(finalXML);
        return finalXML;
      },
    };

  Clamp.State.getTargetByName = (NAME) =>
    Clamp.State.currentProject.characters.find(
      (character) => character.name === NAME,
    );
})();

// oh yeah we got an api but its shit cause i made it üëç
(function (Cap) {
  const DO_VER = 1.6;

  if (!Cap || Cap?.VERSION < DO_VER) {
    console.error(
      `Extension API is missing or outdated.\nPlease use version ${DO_VER} if possible!`,
    );
    return -1;
  }
  if (Cap.VERSION > DO_VER)
    console.warn(
      `Extension API is recommended to be version ${DO_VER} for this extension.\nNewer versions may have updated / removed features, which may cause uninteded side effects.`,
    );

  const {
    compileVars,
    javascriptGenerator,
    canvas,
    State,
    Precompile,
    Blockly,
    DarkTheme,
    Emitter,
  } = window.Clamp;
  const canvasRect = canvas.getBoundingClientRect();
  const Project = () => State.currentProject,
    EditTarget = () => State.getTargetById(State.editingTarget);

  const genColors = (colors) => {
    colors.color1 = colors.primary;
    colors.color2 = colors.secondary;
    colors.color3 = colors.tertiary;
    colors.colourPrimary = colors.primary;
    colors.colourSecondary = colors.secondary;
    colors.colourTertiary = colors.tertiary;
    return colors;
  };
  function stripColors(blockObj) {
    delete blockObj['primary'];
    delete blockObj['secondary'];
    delete blockObj['tertiary'];
    delete blockObj['colourPrimary'];
    delete blockObj['colourSecondary'];
    delete blockObj['colourTertiary'];
    delete blockObj['color1'];
    delete blockObj['color2'];
    delete blockObj['color3'];
    return blockObj;
  }
  function hackBlockColors(blockId, colours) {
    DarkTheme.setBlockStyle(blockId, colours);
    const registeredBlock = Clamp.Blockly.Blocks[blockId];
    const oldInit = registeredBlock.init;
    registeredBlock.init = function (...args) {
      let res = oldInit.call(this, ...args);
      this.colour_ = colours.primary;
      this.colourSecondary_ = colours.secondary;
      this.colourTertiary_ = colours.tertiary;
      this.applyColour();
      return this;
    };
  }
  function changeBlockColour(blockId, colours) {
    if (!Array.isArray(blockId)) {
      hackBlockColors(blockId, colours);
    } else
      for (const id of blockId) {
        hackBlockColors(id, colours);
      }
  }

  window.__ashimeIO = {
    mouseDown: false,
    msSince2000() {
      const start = new Date(2000, 0, 1); // Months are 0-indexed.
      const today = new Date();
      const dstAdjust = today.getTimezoneOffset() - start.getTimezoneOffset();
      let mSecsSinceStart = today.valueOf() - start.valueOf();
      mSecsSinceStart += (today.getTimezoneOffset() - dstAdjust) * 60 * 1000;
      return mSecsSinceStart;
    },
    daysSince2000() {
      return window.__ashimeIO.msSince2000() / (24 * 60 * 60 * 1000);
    },
  };
  window.__ashimeIO.clock = window.__ashimeIO.msSince2000();
  window.__ashimeVars = {
    setupVars() {
      Project().customData = Project()?.customData ?? {};
      Project().customData.ashimeVars = Project().customData?.ashimeVars ?? {};
    },
    getVars() {
      this.setupVars();
      return Project().customData.ashimeVars;
    },
    setVar(n, v) {
      this.setupVars();
      Project().customData.ashimeVars[n] = v;
    },
  };
  document.body.addEventListener(
    'mousedown',
    () => (window.__ashimeIO.mouseDown = true),
  );
  document.body.addEventListener(
    'mouseup',
    () => (window.__ashimeIO.mouseDown = false),
  );
  window.__ashimeEvents = [];
  const menuBar = document.querySelector('div.abovePlayer');
  const clearEventsBtn = menuBar.lastElementChild.cloneNode(true);
  menuBar.appendChild(clearEventsBtn);
  clearEventsBtn.querySelector('div').textContent = 'Clear ALL Events';
  Emitter.on('ashime_clearAllEvents', () => {
    const events = window.__ashimeEvents;
    for (const event of events) {
      document.body.removeEventListener(event[0], event[1]);
    }
    window.__ashimeEvents = [];
  });
  clearEventsBtn.onclick = function () {
    Emitter.emit('ashime_clearAllEvents');
  };

  window.__ashimeCharUtil = {
    switchCostume_assumeId(character, name, inCharacter) {
      inCharacter = inCharacter ?? false;
      const Engine = character._engine;
      const AssumedId = Object.keys(Engine.images).find((key) =>
        key.startsWith(`_user_image_${String(name)}`),
      );
      if (!AssumedId) return;
      window.__ashimeCharUtil.switchCostume_fullId(character, AssumedId);
    },
    switchCostume_fullId(character, id) {
      const Engine = character._engine;
      character.currentImage = id;
      character.updateCharacter();
      character._element.src = Engine.images[id].src;
    },
    engineFetch(characterId, Engine) {
      return Engine.characters.find(character => character.id === character.id);
    }
  };

  Blockly.getMainWorkspace().flyoutButtonCallbacks.set(
    '0znzwClampCredits',
    () => {
      alert(
        'Created by Ashimee.\nCode by Ashimee.\nExtension loader by Ashimee.\n\nAshimee: https://github.com/Ashimee/',
      );
    },
  );

  // https://github.com/ClampProject/Clamp/blob/main/svelte-app/src/resources/blocks/repeats.js
  const repeatDelayTime = 1000 / 60; // how much time before the next iteration in a loop
  const repeatDelayIfEnabled = () => {
    if (!Precompile.forceLoopPauses) return '';
    return `try{await new Promise(resolve => setTimeout(() => resolve(), ${repeatDelayTime}));}catch{};`;
  };

  function dropdownPrioritySelect(dropdownGenerator, nameOrId) {
    const dropdown = dropdownGenerator();
    const namesMatched = [];
    for (const entry of dropdown) {
      console.log(entry);
      if (entry[1] === nameOrId) return entry[1];
      namesMatched.push(entry[0] === nameOrId);
    };
    if (namesMatched.includes(true)) {
      return dropdown[dropdown.indexOf(true)][1];
    } else return null;
  }

  const dynDropdowns = {
    imagesDropdown: function () {
      const menu = [];
      const emptyMenu = [['', '']];
      const character = State.getTargetById(State.editingTarget);
      for (const costumeId of character.costumes) {
        const image = State.getImageById(costumeId);
        menu.push([String(image ? image.name : costumeId), costumeId]);
      }
      if (menu.length <= 0) return emptyMenu;
      return menu;
    },
    spritesDropdown: function () {
      const menu = [];
      const emptyMenu = [['', '']];
      for (const character of State.currentProject.characters) {
        menu.push([String(character.name ? character.name : character.id), character.id]);
      }
      if (menu.length <= 0) return emptyMenu;
      return menu;
    },
  };

  const dropdowns = {
    imagesDropdown: {
      skipXMLpush: true,
      opcode: 'imagesDropdown',
      text: '%1',
      arguments: [
        {
          type: 'field_dropdown',
          name: 'IMAGE',
          options: dynDropdowns.imagesDropdown,
        },
      ],
      output: ['String'],
      inputsInline: true,
      generator: function (block) {
        let IMAGE = block.getFieldValue('IMAGE');
        IMAGE = dropdownPrioritySelect(dynDropdowns.imagesDropdown, IMAGE);
        const code = `${JSON.stringify(IMAGE)}`;
        return [`(${code})`, javascriptGenerator.ORDER_NONE];
      },
    },
    spritesDropdown: {
      skipXMLpush: true,
      opcode: 'spritesDropdown',
      text: '%1',
      arguments: [
        {
          type: 'field_dropdown',
          name: 'SPRITE',
          options: dynDropdowns.spritesDropdown,
        },
      ],
      output: ['String'],
      inputsInline: true,
      generator: function (block) {
        let SPRITE = block.getFieldValue('SPRITE');
        SPRITE = dropdownPrioritySelect(dynDropdowns.spritesDropdown, SPRITE);
        const code = `${JSON.stringify(SPRITE)}`;
        return [`(${code})`, javascriptGenerator.ORDER_NONE];
      },
    },
  };

  const CreditsColors = genColors({
    primary: '#CF63CF',
    secondary: '#C94FC9',
    tertiary: '#BD42BD',
  });
  const CreditsXML = Cap.register({
    id: '0znzwClampCredits',
    name: 'ClampCharged | v2.0', // such an original name ik!
    ...CreditsColors,
    skipPush: true,
    blocks: [
      {
        isXML:
          '<button callbackKey="0znzwClampCredits" text="Credits"></button>',
      },
      {
        opcode: 'debug',
        text: 'debug;',
        nextStatement: null,
        previousStatement: null,
        arguments: [],
      },
    ],
    generators: {
      debug(block) {
        console.log(block);
        return `\nconsole.log(this, character);debugger;\n`;
      },
    },
  });

  const MotionColors = genColors({
    primary: '#4C97FF',
    secondary: '#4280D7',
    tertiary: '#3373CC',
  });
  const MotionXML = Cap.register({
    id: '0znzwClampMotion',
    name: 'Motion (WIP)',
    ...MotionColors,
    skipPush: true,
    blocks: [
      {
        opcode: 'move',
        text: 'move %1 steps in direction %2',
        previousStatement: null,
        nextStatement: null,
        arguments: [
          {
            type: 'field_number',
            name: 'STEPS',
            check: 'Number',
            value: 10,
            acceptsBlocks: true,
          },
          {
            type: 'field_angle',
            name: 'ANGLE',
            check: 'Number',
            angle: 0,
            acceptsBlocks: true,
          },
        ],
      },
      {
        opcode: 'pointInDir',
        text: 'point in direction %1',
        previousStatement: null,
        nextStatement: null,
        arguments: [
          {
            type: 'field_angle',
            name: 'ANGLE',
            check: 'Number',
            angle: 0,
            acceptsBlocks: true,
          },
        ],
      },
      {
        opcode: 'pointXY',
        text: 'point towards x: %1 y: %2',
        previousStatement: null,
        nextStatement: null,
        arguments: [
          {
            type: 'field_number',
            name: 'X',
            check: 'Number',
            value: 240,
            acceptsBlocks: true,
          },
          {
            type: 'field_number',
            name: 'Y',
            check: 'Number',
            value: 180,
            acceptsBlocks: true,
          },
        ],
      },
      {
        opcode: 'setXY',
        text: 'go to x: %1 y: %2',
        previousStatement: null,
        nextStatement: null,
        arguments: [
          {
            type: 'field_number',
            name: 'X',
            check: 'Number',
            value: 0,
            acceptsBlocks: true,
          },
          {
            type: 'field_number',
            name: 'Y',
            check: 'Number',
            value: 0,
            acceptsBlocks: true,
          },
        ],
      },
      {
        opcode: 'changeXY',
        text: 'change x by: %1 y by: %2',
        previousStatement: null,
        nextStatement: null,
        arguments: [
          {
            type: 'field_number',
            name: 'X',
            check: 'Number',
            value: 10,
            acceptsBlocks: true,
          },
          {
            type: 'field_number',
            name: 'Y',
            check: 'Number',
            value: 10,
            acceptsBlocks: true,
          },
        ],
      },
      {
        opcode: 'getX',
        text: 'x position',
        output: ['Number'],
      },
      {
        opcode: 'getY',
        text: 'y position',
        output: ['Number'],
      },
      {
        opcode: 'getDir',
        text: 'direction',
        output: ['Number'],
      },
    ],
    generators: {
      move(block) {
        const STEPS = javascriptGenerator.valueToCode(
          block,
          'STEPS',
          javascriptGenerator.ORDER_ATOMIC,
        );
        const ANGLE = javascriptGenerator.valueToCode(
          block,
          'ANGLE',
          javascriptGenerator.ORDER_ATOMIC,
        );
        const x = compileVars.next(),
          y = compileVars.next(),
          dx = compileVars.next(),
          dy = compileVars.next();
        return `\nvar ${x} = character.position.x, ${y} = character.position.y;
                  var ${dx} = (${STEPS}*Math.sin(${ANGLE})), ${dy} = (${STEPS}*Math.cos(${ANGLE}));
                  character.gotoXY(${x} + ${dx}, ${y} + ${dy});`;
      },
      pointInDir(block) {
        const ANGLE = javascriptGenerator.valueToCode(
          block,
          'ANGLE',
          javascriptGenerator.ORDER_ATOMIC,
        );
        return `\ncharacter.rotateTo(${ANGLE});`;
      },
      changeXY(block) {
        const X = javascriptGenerator.valueToCode(
          block,
          'X',
          javascriptGenerator.ORDER_ATOMIC,
        );
        const Y = javascriptGenerator.valueToCode(
          block,
          'Y',
          javascriptGenerator.ORDER_ATOMIC,
        );
        return `\ncharacter.changeXY(${X}, ${Y});`;
      },
      setXY(block) {
        const X = javascriptGenerator.valueToCode(
          block,
          'X',
          javascriptGenerator.ORDER_ATOMIC,
        );
        const Y = javascriptGenerator.valueToCode(
          block,
          'Y',
          javascriptGenerator.ORDER_ATOMIC,
        );
        return `\ncharacter.gotoXY(${X}, ${Y});`;
      },
      pointXY(block) {
        const X = javascriptGenerator.valueToCode(
          block,
          'X',
          javascriptGenerator.ORDER_ATOMIC,
        );
        const Y = javascriptGenerator.valueToCode(
          block,
          'Y',
          javascriptGenerator.ORDER_ATOMIC,
        );
        return `\ncharacter.rotateTo(
          ((180 / Math.PI) *
            Math.atan((${X} - character.position.x) / (${Y} - character.position.y)) +
            ( Number(${Y} > character.position.y) * 180 ) + 90)
        );`;
      },
      getX(block) {
        return [`(character.position.x)`, Clamp.javascriptGenerator.ORDER_NONE];
      },
      getY(block) {
        return [`(character.position.y)`, Clamp.javascriptGenerator.ORDER_NONE];
      },
      getDir(block) {
        return [`(character.rotation)`, Clamp.javascriptGenerator.ORDER_NONE];
      },
    },
  });

  const LooksColors = genColors({
    primary: '#9966FF',
    secondary: '#855CD6',
    tertiary: '#774DCB',
  });
  const LooksXML = Cap.register({
    id: '0znzwClampLooks',
    name: 'Looks (WIP)',
    ...LooksColors,
    skipPush: true,
    blocks: [
      dropdowns.imagesDropdown,
      {
        skipXMLpush: true,
        opcode: 'showHideDropdown',
        text: '%1',
        arguments: [
          {
            type: 'field_dropdown',
            name: 'OPT',
            options: [
              ['show', 'show'],
              ['hide', 'hide'],
            ],
          },
        ],
        output: ['String'],
      },
      {
        skipXMLpush: true,
        opcode: 'showHide',
        text: '%1 sprite',
        previousStatement: null,
        nextStatement: null,
        arguments: [
          {
            type: 'field_input',
            name: 'OPT',
            check: 'String',
            text: 'show',
            spellcheck: false,
            value: '',
            acceptsBlocks: true,
          },
        ],
      },
      {
        isXML: `<block type="clampExt_0znzwClampLooks_showHide"><value name="OPT"><shadow type="clampExt_0znzwClampLooks_showHideDropdown"></shadow></value></block>`,
      },
      {
        skipXMLpush: true,
        opcode: 'switchCostume',
        text: 'switch costume to %1',
        previousStatement: null,
        nextStatement: null,
        arguments: [
          {
            type: 'field_input',
            name: 'NAME',
            check: 'String',
            text: 'Apple',
            spellcheck: false,
            value: '',
            acceptsBlocks: true,
          },
        ],
      },
      {
        isXML: `<block type="clampExt_0znzwClampLooks_switchCostume"><value name="NAME"><shadow type="clampExt_0znzwClampLooks_imagesDropdown"></shadow></value></block>`,
      },
      {
        opcode: 'isShown',
        text: 'is this sprite visible?',
        output: 'Boolean',
        arguments: [],
      },
    ],
    generators: {
      imagesDropdown: dropdowns.imagesDropdown.generator,
      showHideDropdown() {
        let SHOW_HIDE = String(block.getFieldValue('OPT').toLowerCase());
        return [
          `("${SHOW_HIDE === 'show' ? 'show' : 'hide'}")`,
          javascriptGenerator.ORDER_NONE,
        ];
      },
      showHide(block) {
        let SHOW_HIDE = block.getFieldValue('OPT');
        switch (SHOW_HIDE) {
          case 'show':
            return `\ncharacter.show();`;
          default:
            return `\ncharacter.hide();`;
        }
      },
      switchCostume(block) {
        const NAME = javascriptGenerator.valueToCode(
          block,
          'NAME',
          javascriptGenerator.ORDER_ATOMIC,
        );
        return `\nwindow.__ashimeCharUtil.switchCostume_fullId(character, String(${NAME}), true);`;
      },
      isShown(block) {
        return [
          `(Clamp.State.getTargetById("${State.editingTarget}").visible)`,
          javascriptGenerator.ORDER_NONE,
        ];
      },
    },
  });

  const SoundsColors = genColors({
    primary: '#CF63CF',
    secondary: '#C94FC9',
    tertiary: '#BD42BD',
  });
  const SoundsXML = Cap.register({
    id: '0znzwClampSounds',
    name: 'Sounds (WIP)',
    ...SoundsColors,
    skipPush: true,
    blocks: [],
    generators: {},
  });

  const EventsColors = genColors({
    primary: '#FFBF00',
    secondary: '#E6AC00',
    tertiary: '#CC9900',
  });
  const EventsXML = Cap.register({
    id: '0znzwClampEvents',
    name: 'Events (WIP)',
    ...EventsColors,
    skipPush: true,
    blocks: [
      {
        skipXMLpush: true,
        opcode: 'whenkeyaction_shadowMenu',
        text: '%1',
        output: ['String'],
        arguments: [
          {
            type: 'field_dropdown',
            name: 'ITEM',
            options: [
              ['pressed', 'pressed'],
              ['down', 'down'],
              ['up', 'up'],
            ],
          },
        ],
      },
      {
        skipXMLpush: true,
        opcode: 'whenkeyaction',
        text: 'when key %1 %2 %3',
        arguments: [
          {
            type: 'input_value',
            name: 'ACTION',
            check: 'String',
            value: '',
            acceptsBlocks: false,
          },
          {
            type: 'input_dummy',
          },
          {
            type: 'input_statement',
            name: 'BLOCKS',
          },
        ],
      },
      {
        isXML: `<block type="actions_whenrunclicked" />
        <block type="actions_whenstopclicked" />
        <block type="actions_whencharacterclicked" />
        <block type="clampExt_0znzwClampEvents_whenkeyaction"><value name="ACTION"><shadow type="clampExt_0znzwClampEvents_whenkeyaction_shadowMenu"></shadow></value></block>`,
      },
    ],
    generators: {
      whenkeyaction_shadowMenu(block) {
        const SELECTED = block.getFieldValue('ITEM');
        return [
          `("${SELECTED.replaceAll('\\', '\\\\').replaceAll('"', '"')}")`,
          Clamp.javascriptGenerator.ORDER_NONE,
        ];
      },
      whenkeyaction(block) {
        console.log(block);
        const ACTION = javascriptGenerator.valueToCode(
          block,
          'ACTION',
          javascriptGenerator.ORDER_ATOMIC,
        );
        const BLOCKS = javascriptGenerator.statementToCode(block, 'BLOCKS');
        var varName = compileVars.next(),
          event = compileVars.next(),
          arg = compileVars.next(),
          blockId = compileVars.next(),
          blockObj = compileVars.next();
        var keydown = compileVars.next(),
          keyup = compileVars.next(),
          keypressed = compileVars.next();
        const events = `var ${keydown} = (...a)=>{${varName}('keydown', ...a)}, ${keyup} = (...a)=>{${varName}('keyup', ...a)}, ${keypressed} = (...a)=>{${varName}('keypressed', ...a)};
                        document.body.addEventListener('keydown', ${keydown});
                        document.body.addEventListener('keyup', ${keyup});
                        document.body.addEventListener('keypressed', ${keypressed});
                        window.__ashimeEvents.push(['keydown', ${keydown}]);
                        window.__ashimeEvents.push(['keyup', ${keyup}]);
                        window.__ashimeEvents.push(['keypressed', ${keypressed}]);
                        Clamp.Emitter.on('CODE_INITIALIZE_UPDATE', ()=>{
                          Clamp.Emitter.emit('ashime_clearAllEvents');
                        });`;
        return `\nvar ${blockId} = '${block.id}';
        var ${varName} = (${arg}, ${event}) => {
          if ('key'+String(${ACTION}) === String(${arg})) {\n ${BLOCKS} \n};
          return;
          // sadly this wont work on multisprite :sob:
          var ${blockObj} = Clamp.getWorkspace().getBlockById(${blockId});
          ${blockObj} = eval(Clamp.javascriptGenerator.valueToCode(
            ${blockObj},
            'ACTION',
            Clamp.javascriptGenerator.ORDER_ATOMIC,
          ));
          console.log(${arg}, ${blockObj});
          if ('key'+String(${blockObj}) === String(${arg})) {\n ${BLOCKS} \n};
        };${events}`;
      },
    },
  });
  changeBlockColour(
    [
      'actions_whenrunclicked',
      'actions_whenstopclicked',
      'actions_whencharacterclicked',
    ],
    EventsColors,
  );

  const ControlColors = genColors({
    primary: '#FFAB19',
    secondary: '#EC9C13',
    tertiary: '#CF8B17',
  });
  const ControlXML = Cap.register({
    id: '0znzwClampControl',
    name: 'Control (WIP)',
    ...ControlColors,
    skipPush: true,
    blocks: [
      {
        opcode: 'FORloop',
        text: 'for %1 = %2 to %3 %4 %5',
        previousStatement: null,
        nextStatement: null,
        arguments: [
          {
            type: 'field_input',
            name: 'NAME',
            check: 'String',
            text: 'my variable',
            spellcheck: false,
            value: '',
            acceptsBlocks: true,
          },
          {
            type: 'field_number',
            name: 'START',
            check: ['Number'],
            value: 0,
            acceptsBlocks: true,
          },
          {
            type: 'field_number',
            name: 'END',
            check: ['Number'],
            value: 10,
            acceptsBlocks: true,
          },
          {
            type: 'input_dummy',
          },
          {
            type: 'input_statement',
            name: 'BLOCKS',
          },
        ],
      },
      {
        opcode: 'repeat',
        text: 'repeat %1 %2 %3',
        previousStatement: null,
        nextStatement: null,
        arguments: [
          {
            type: 'field_number',
            name: 'TIMES',
            check: ['Number'],
            value: 5,
            acceptsBlocks: true,
          },
          {
            type: 'input_dummy',
          },
          {
            type: 'input_statement',
            name: 'BLOCKS',
          },
        ],
      },
      {
        opcode: 'forever',
        text: 'forever %1 %2',
        previousStatement: null,
        arguments: [
          {
            type: 'input_dummy',
          },
          {
            type: 'input_statement',
            name: 'BLOCKS',
          },
        ],
      },
      {
        opcode: 'repeatUntil',
        text: 'repeat until %1 %2 %3',
        previousStatement: null,
        nextStatement: null,
        arguments: [
          {
            type: 'input_value',
            name: 'BOOL',
            check: 'Boolean',
            acceptsBlocks: true,
          },
          {
            type: 'input_dummy',
          },
          {
            type: 'input_statement',
            name: 'BLOCKS',
          },
        ],
      },
      {
        opcode: 'ifCheck',
        text: 'if %1 then %2 %3',
        previousStatement: null,
        nextStatement: null,
        arguments: [
          {
            type: 'input_value',
            name: 'BOOL',
            check: 'Boolean',
            acceptsBlocks: true,
          },
          {
            type: 'input_dummy',
          },
          {
            type: 'input_statement',
            name: 'BLOCKS_1',
          },
        ],
      },
      {
        opcode: 'ifElseCheck',
        text: 'if %1 then %2 %3 else %4 %5',
        previousStatement: null,
        nextStatement: null,
        arguments: [
          {
            type: 'input_value',
            name: 'BOOL',
            check: 'Boolean',
            acceptsBlocks: true,
          },
          {
            type: 'input_dummy',
          },
          {
            type: 'input_statement',
            name: 'BLOCKS_1',
          },
          {
            type: 'input_dummy',
          },
          {
            type: 'input_statement',
            name: 'BLOCKS_2',
          },
        ],
      },
      {
        isXML: `<block type="actions_waitSeconds"></block>
        <block type="actions_waitframe"></block>
        <block type="actions_showmessage"></block>
        <block type="actions_stopscript"></block>`,
      },
    ],
    generators: {
      forLoop(block) {
        const NAME = javascriptGenerator.valueToCode(
          block,
          'NAME',
          javascriptGenerator.ORDER_ATOMIC,
        );
        const START = javascriptGenerator.valueToCode(
          block,
          'START',
          javascriptGenerator.ORDER_ATOMIC,
        );
        const END = javascriptGenerator.valueToCode(
          block,
          'END',
          javascriptGenerator.ORDER_ATOMIC,
        );
        const BLOCKS = javascriptGenerator.statementToCode(block, 'BLOCKS');
        const varName = compileVars.next();
        return `\nwindow.__ashimeVars.setVar(${NAME}, 0);for (let ${varName} = ${START}; ${varName} < ${END}+1; ${varName}++) {window.__ashimeVars.setVar(${NAME}, ${varName}); \n ${BLOCKS} }`;
      },
      repeat(block) {
        const COUNT = javascriptGenerator.valueToCode(
          block,
          'TIMES',
          javascriptGenerator.ORDER_ATOMIC,
        );
        const BLOCKS = javascriptGenerator.statementToCode(block, 'BLOCKS');
        const varName = compileVars.next();
        return `\nfor (let ${varName} = 0; ${varName} < ${COUNT}; ${varName}++) { \n${BLOCKS}\n }`;
      },
      forever(block) {
        // JeremyGamer13 made this function, I modified it for my uses.
        const BLOCKS = javascriptGenerator.statementToCode(block, 'BLOCKS');
        return `while (!character.disposed) { ${BLOCKS} \n ${repeatDelayIfEnabled()} };`;
      },
      repeatUntil(block) {
        // JeremyGamer13 made this function, I modified it for my uses.
        const CONDITION = javascriptGenerator.valueToCode(
          block,
          'BOOL',
          javascriptGenerator.ORDER_ATOMIC,
        );
        const BLOCKS = javascriptGenerator.statementToCode(block, 'BLOCKS');
        return `while ((!(${CONDITION ? CONDITION : 'false'})) && !character.disposed) { ${BLOCKS} \n ${repeatDelayIfEnabled()} };`;
      },
      ifCheck(block) {
        const CONDITION = javascriptGenerator.valueToCode(
          block,
          'BOOL',
          javascriptGenerator.ORDER_ATOMIC,
        );
        const TRUE_BLOCKS = javascriptGenerator.statementToCode(
          block,
          'BLOCKS_1',
        );
        // const FALSE_BLOCKS = javascriptGenerator.statementToCode(block, 'BLOCKS_2');
        return `\nif (Boolean(${CONDITION})) { \n${TRUE_BLOCKS}\n } else { };`;
      },
      ifElseCheck(block) {
        const CONDITION = javascriptGenerator.valueToCode(
          block,
          'BOOL',
          javascriptGenerator.ORDER_ATOMIC,
        );
        const TRUE_BLOCKS = javascriptGenerator.statementToCode(
          block,
          'BLOCKS_1',
        );
        const FALSE_BLOCKS = javascriptGenerator.statementToCode(
          block,
          'BLOCKS_2',
        );
        return `\nif (Boolean(${CONDITION})) { \n${TRUE_BLOCKS}\n } else { \n${FALSE_BLOCKS}\n };`;
      },
      attemptBreak(block) {
        return `try{break;}catch{};`;
      },
      switch_(block) {
        const BLOCKS = javascriptGenerator.statementToCode(block, 'BLOCKS');
        return ``;
      },
      case_(block) {
        const BLOCKS = javascriptGenerator.statementToCode(block, 'BLOCKS');
        return ``;
      },
      default_(block) {
        const BLOCKS = javascriptGenerator.statementToCode(block, 'BLOCKS');
        return ``;
      },
    },
  });
  changeBlockColour(
    [
      'actions_waitSeconds',
      'actions_waitframe',
      'actions_showmessage',
      'actions_stopscript',
    ],
    ControlColors,
  );

  const SensingColors = genColors({
    primary: '#5CB1D6',
    secondary: '#47A8D1',
    tertiary: '#2E8EB8',
  });
  const SensingXML = Cap.register({
    id: '0znzwClampSensing',
    name: 'Sensing (WIP)',
    ...SensingColors,
    skipPush: true,
    blocks: [
      dropdowns.spritesDropdown,
      {
        opcode: 'isMouseDown',
        text: 'mouse down?',
        output: ['Boolean'],
      },
      {
        opcode: 'isMouseBtn',
        text: 'mouse button %1 pressed?',
        arguments: [
          {
            type: 'field_dropdown',
            name: 'BUTTON',
            options: [
              ['left', 'leftdown'],
              ['right', 'rightdown'],
              ['middle', 'middledown'],
            ],
          },
        ],
        output: ['Boolean'],
      },
      {
        opcode: 'getMouseX',
        text: 'mouse x',
        output: ['Number'],
      },
      {
        opcode: 'getMouseY',
        text: 'mouse y',
        output: ['Number'],
      },
      {
        skipXMLpush: true,
        opcode: 'isTouching',
        text: 'is %1 touching %2?',
        arguments: [
          {
            type: 'field_input',
            name: 'SPRITE1',
            check: 'String',
            text: 'show',
            spellcheck: false,
            value: '',
            acceptsBlocks: true,
          },
          {
            type: 'field_input',
            name: 'SPRITE2',
            check: 'String',
            text: 'show',
            spellcheck: false,
            value: '',
            acceptsBlocks: true,
          },
        ],
        output: ['Boolean'],
      },
      {
    	isXML: `<block type="clampExt_0znzwClampSensing_isTouching"><value name="SPRITE1"><shadow type="clampExt_0znzwClampSensing_spritesDropdown"></shadow></value><value name="SPRITE2"><shadow type="clampExt_0znzwClampSensing_spritesDropdown"></shadow></value></block>`,
      },
      {
        opcode: 'daysSinceY2K',
        text: 'days since 2000',
        output: ['Number'],
      },
      {
        opcode: 'resetTimer',
        text: 'reset timer',
        nextStatement: null,
        previousStatement: null,
      },
      {
        opcode: 'getTimer',
        text: 'timer',
        output: ['Number'],
      },
    ],
    generators: {
      spritesDropdown: dropdowns.spritesDropdown.generator,
      isMouseDown(block) {
        return [
          `(Clamp.InputDevice._data.mousedown)`,
          Clamp.javascriptGenerator.ORDER_NONE,
        ];
      },
      isMouseBtn(block) {
        // jwklong made dis function
        const BUTTON = block.getFieldValue('BUTTON');
        const code = `Clamp.InputDevice.mouse[${JSON.stringify(BUTTON)}]`;
        return [`(${code})`, javascriptGenerator.ORDER_NONE];
      },
      getMouseX(block) {
        return [
          `(Clamp.InputDevice._data.mousex)`,
          Clamp.javascriptGenerator.ORDER_NONE,
        ];
      },
      getMouseY(block) {
        return [
          `(Clamp.InputDevice._data.mousey)`,
          Clamp.javascriptGenerator.ORDER_NONE,
        ];
      },
      daysSinceY2K() {
        return [
          `(window.__ashimeIO.daysSince2000())`,
          Clamp.javascriptGenerator.ORDER_NONE,
        ];
      },
      resetTimer() {
        return 'window.__ashimeIO.clock = window.__ashimeIO.msSince2000()';
      },
      getTimer() {
        return [
          `(((window.__ashimeIO.msSince2000() - window.__ashimeIO.clock) / 1000))`,
          Clamp.javascriptGenerator.ORDER_NONE,
        ];
      },
      isTouching(block) {
      	const SPRITE1 = javascriptGenerator.valueToCode(
          block,
          'SPRITE1',
          javascriptGenerator.ORDER_ATOMIC,
        );
        const SPRITE2 = javascriptGenerator.valueToCode(
          block,
          'SPRITE2',
          javascriptGenerator.ORDER_ATOMIC,
        );
        const s1 = compileVars.next(), s2 = compileVars.next();
        const s1a = compileVars.next(), s2a = compileVars.next();
        const s1b = compileVars.next(), s2b = compileVars.next();
        const s1sc = compileVars.next(), s2sc = compileVars.next();
        const s1p = compileVars.next(), s2p = compileVars.next();
        const over = compileVars.next();
        console.log(SPRITE1, SPRITE2);
        return [
          `((function(){
              var ${s1a} = Clamp.State.getTargetById(${SPRITE1});
              var ${s2a} = Clamp.State.getTargetById(${SPRITE2});
              var ${s1} = window.__ashimeCharUtil.engineFetch(${SPRITE1}, Engine);
              var ${s2} = window.__ashimeCharUtil.engineFetch(${SPRITE2}, Engine);
              var ${s1b} = ${s1}.element.getBoundingClientRect();
              var ${s2b} = ${s2}.element.getBoundingClientRect();
              var ${s1sc} = (${s1a}.size/100), ${s2sc} = (${s2a}.size/100);
              ${s1sc} = {w: (${s1sc}*${s1b}.width), h: (${s1sc}*${s1b}.height)};
              ${s2sc} = {w: (${s2sc}*${s2b}.width), h: (${s2sc}*${s2b}.height)};
              var ${s1p} = {
                tl: {
                  x: (${s1a}.position.x - ${s1sc}.w/2),
                  y: (${s1a}.position.y + ${s1sc}.h/2)
                },
                tr: {
                    x: (${s1a}.position.x + ${s1sc}.w/2),
                    y: (${s1a}.position.y + ${s1sc}.h/2)
                },
                bl: {
                    x: (${s1a}.position.x - ${s1sc}.w/2),
                    y: (${s1a}.position.y - ${s1sc}.h/2)
                },
                br: {
                    x: (${s1a}.position.x + ${s1sc}.w/2),
                    y: (${s1a}.position.y - ${s1sc}.h/2)
                },
              };
              var ${s2p} = {
                tl: {
                  x: (${s2a}.position.x - ${s2sc}.w/2),
                  y: (${s2a}.position.y + ${s2sc}.h/2)
                },
                tr: {
                    x: (${s2a}.position.x + ${s2sc}.w/2),
                    y: (${s2a}.position.y + ${s2sc}.h/2)
                },
                bl: {
                    x: (${s2a}.position.x - ${s2sc}.w/2),
                    y: (${s2a}.position.y - ${s2sc}.h/2)
                },
                br: {
                    x: (${s2a}.position.x + ${s2sc}.w/2),
                    y: (${s2a}.position.y - ${s2sc}.h/2)
                },
              };
              // X checks
              if (${s1p}.tr.x < ${s2p}.tl.x || ${s1p}.tl.x > ${s2p}.tr.x) return false;
              if (${s1p}.br.x < ${s2p}.bl.x || ${s1p}.bl.x > ${s2p}.br.x) return false;
              // Y checks

              return true;
          })('This is a stupid way to do it ik.'))`,
          Clamp.javascriptGenerator.ORDER_NONE,
        ];
      },
    },
  });

  const OperatorsColors = genColors({
    primary: '#59C059',
    secondary: '#46B946',
    tertiary: '#389438',
  });
  const OperatorsXML = Cap.register({
    id: '0znzwClampOperators',
    name: 'Operators',
    ...OperatorsColors,
    skipPush: true,
    blocks: [
      {
        isXML: `<block type="operations_mathoperations" />
        <block type="operations_equaloperations" />
        <block type="operations_andor" />
        <block type="operations_not" />
        <block type="operations_bools" />
        <label text="" />
        <block type="operations_randomnumber" />
        <label text="" />
        <block type="operations_join" />
        <block type="operations_lengthof" />
        <block type="operations_letterof" />
        <block type="operations_lettersfromtoin" />
        <label text="" />
        <block type="operations_includes" />
        <block type="operations_indexofin" />
        <block type="operations_startsendswith" />
        <label text="" />
        <block type="operations_replacechars" />
        <block type="operations_casingstring" />
        <label text="" />
        <block type="operations_doublemathoperations" />
        <block type="operations_advancedoperations" />
        <label text="" />`,
      },
      {
        opcode: 'STRcast',
        text: 'str %1',
        output: ['String'],
        arguments: [
          {
            type: 'field_input',
            name: 'castMe',
            check: null,
            text: 'stringggggg',
            spellcheck: false,
            value: '',
            acceptsBlocks: true,
          },
        ],
      },
      {
        opcode: 'NUMcast',
        text: 'num %1',
        output: ['Number'],
        arguments: [
          {
            type: 'field_number',
            name: 'castMe',
            check: null,
            value: 0,
            acceptsBlocks: true,
          },
        ],
      },
      {
        opcode: 'BOOLcast',
        text: 'bool %1',
        output: ['Boolean'],
        arguments: [
          {
            type: 'field_input',
            name: 'castMe',
            check: null,
            text: '1',
            spellcheck: false,
            value: '',
            acceptsBlocks: true,
          },
        ],
      },
    ],
    generators: {
      STRcast(block) {
        const toCast = javascriptGenerator.valueToCode(
          block,
          'castMe',
          javascriptGenerator.ORDER_ATOMIC,
        );
        return [`String(${toCast})`, Clamp.javascriptGenerator.ORDER_NONE];
      },
      NUMcast(block) {
        const toCast = javascriptGenerator.valueToCode(
          block,
          'castMe',
          javascriptGenerator.ORDER_ATOMIC,
        );
        return [`Number(${toCast})`, Clamp.javascriptGenerator.ORDER_NONE];
      },
      BOOLcast(block) {
        const toCast = javascriptGenerator.valueToCode(
          block,
          'castMe',
          javascriptGenerator.ORDER_ATOMIC,
        );
        return [`Boolean(${toCast})`, Clamp.javascriptGenerator.ORDER_NONE];
      },
    },
  });

  const VariableColors = genColors({
    primary: '#FF8C1A',
    secondary: '#FF8000',
    tertiary: '#DB6E00',
  });
  const VariablesXML = Cap.register({
    id: '0znzwClampSensing',
    name: 'Variables (Saves 2 Project)',
    ...VariableColors,
    skipPush: true,
    blocks: [
      {
        opcode: 'exists',
        text: 'variable %1 exists?',
        output: ['Boolean'],
        arguments: [
          {
            type: 'field_input',
            name: 'NAME',
            check: 'String',
            text: 'my variable',
            spellcheck: false,
            value: '',
            acceptsBlocks: true,
          },
        ],
      },
      {
        opcode: 'get',
        text: 'get variable %1',
        output: null,
        arguments: [
          {
            type: 'field_input',
            name: 'NAME',
            check: 'String',
            text: 'my variable',
            spellcheck: false,
            value: '',
            acceptsBlocks: true,
          },
        ],
      },
      {
        opcode: 'set',
        text: 'set variable %1 to %2',
        previousStatement: null,
        nextStatement: null,
        arguments: [
          {
            type: 'field_input',
            name: 'NAME',
            check: 'String',
            text: 'my variable',
            spellcheck: false,
            value: '',
            acceptsBlocks: true,
          },
          {
            type: 'field_input',
            name: 'VALUE',
            check: null,
            text: '0',
            spellcheck: false,
            value: '',
            acceptsBlocks: true,
          },
        ],
      },
    ],
    generators: {
      exists(block) {
        const NAME = javascriptGenerator.valueToCode(
          block,
          'NAME',
          javascriptGenerator.ORDER_ATOMIC,
        );
        return [
          `(window.__ashime.getVars().hasOwnProperty(${NAME}))`,
          Clamp.javascriptGenerator.ORDER_NONE,
        ];
      },
      get(block) {
        const NAME = javascriptGenerator.valueToCode(
          block,
          'NAME',
          javascriptGenerator.ORDER_ATOMIC,
        );
        return [
          `(window.__ashimeVars.getVars()[${NAME}] ?? '')`,
          Clamp.javascriptGenerator.ORDER_NONE,
        ];
      },
      set(block) {
        const NAME = javascriptGenerator.valueToCode(
          block,
          'NAME',
          javascriptGenerator.ORDER_ATOMIC,
        );
        const VALUE = javascriptGenerator.valueToCode(
          block,
          'VALUE',
          javascriptGenerator.ORDER_ATOMIC,
        );
        return `window.__ashimeVars.setVar(${NAME}, ${VALUE});`;
      },
    },
  });

  const AFTER_POS =
    Clamp.Toolbox.indexOf(
      '</category>',
      Clamp.Toolbox.indexOf('<category name="Tables"'),
    ) + 11;
  const AFTER_XML = Clamp.Toolbox.substr(
    AFTER_POS,
    Clamp.Toolbox.indexOf('</xml>'),
  );
  const FULL_XML = `<xml>\n${CreditsXML}\n${MotionXML}\n${LooksXML}\n${SoundsXML}\n${EventsXML}\n${ControlXML}\n${SensingXML}\n${OperatorsXML}\n${VariablesXML}\n${AFTER_XML}\n`;
  console.log(FULL_XML);
  Clamp.ExtAPI.refreshToolbox(FULL_XML);
  Clamp.getWorkspace().refreshTheme();

  Clamp.enableLogOutput();
  return 1;
})(Clamp?.ExtAPI);
